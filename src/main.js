// in short, "use strict" will clean up some of the messier behaviors of javascript,
// and help us to avoid frustrating bugs, in exchange for being stricter about our syntax.
// Errors generated by use strict will show up in the console window of the browser!
"use strict";

// this line at the top of all the files makes sure that they all have access to the same app object,
// independent of when the browser loads the js files. Either app is already defined from another file, or 
// app evaluates to undefined (or false) and then it is instantiated with {} into an empty object.
// each "var app" is thus a pointer to the same object, essentially, even though they are all different variables.
var app = app || {};


// main is instantiated with an IIFE, or immediately invoked function expression. Because the function has a () after its
// closing brace, it is immediately executed upon being declared, and main is assigned its return value. Because the function
// is anonymous, it can never be run again - making its internal scope private to the objects and functions declared within it,
// and effectively making main (and other modules instantiated this way) into a singleton, in some sense. They are initialized 
// once, and their initialization logic can never be executed again elsewhere.
app.main = function(){

	// this obj will eventually be app.main
	var obj = {};
	
	var playerLocation = {row: 0, col: 0};
	
	obj.map = [[1, 0, 1, 1],
		       [1, 1, 1, 0],
			   [0, 0, 1, 0]];
    
    obj.enemy = {type: 'wizlock', trait1: 'timid', trait2: 'talkative'};
	
	//Buttons
	obj.directionButtons = {};

	// loader is a sub module of main, also instantiated with an IIFE.
	// it will be used to load JSON objects asynchronously
	obj.loader = function(){

		// this will eventually be app.main.loader
		var obj = {};

		// this variable will be accessible only to functions inside of app.main.loader
		// it tracks the number of json files that are currently being loaded asynchronously
		// so we can tell when it is safe to proceed with game execution
		var filesLoading = 0;

		// loads a JSON file, and calls the callback function with the data in the JSON file once it has
		// finished loading.
		obj.loadJSON = function(filepath,callback){
			filesLoading++;

			var request = new XMLHttpRequest();
			request.open('GET',filepath);
			request.responseType = 'json';
			request.send();
			request.onload = onResponseReceived;
			request.onerror = function(){console.log("error loading "+ filepath);};
			

			function onResponseReceived(){
				callback(request.response);
				filesLoading--;
			}

		};

		return obj;
	}();
	
	obj.init = function(){
		//Initialization code goes here?
		
		var canvas = document.querySelector("canvas");
		var ctx = canvas.getContext('2d');
		
		canvas.onmousemove = function(e){
			var mouse = getMouse(e);
			callFunctionMovementButtons.call(app.main, "checkHover", mouse);
		};
		
		canvas.onmousedown = function(e){
			var mouse = getMouse(e);
			callFunctionMovementButtons.call(app.main, "checkClick", mouse);
		};
		
		app.main.directionButtons = {
			left: new Button(ctx, canvas.width / 2 - 250, canvas.height / 2 - 50, 200, 100, "grey", "green", "red", "white", "Go Left",
			function(){movePlayer("left")}),
			right: new Button(ctx, canvas.width / 2 + 100, canvas.height / 2 - 50, 200, 100, "grey", "green", "red", "white", "Go Right",
			function(){movePlayer("right")}),
			up: new Button(ctx, canvas.width / 2 - 100, canvas.height / 2 - 200, 200, 100, "grey", "green", "red", "white", "Go Up",
			function(){movePlayer("up")}),
			down: new Button(ctx, canvas.width / 2 - 100, canvas.height / 2 + 100, 200, 100, "grey", "green", "red", "white", "Go Down",
			function(){movePlayer("down")})
		};
        
        
        app.main.enemy = {type: 'wizlock', trait1: 'foppish', trait2: 'sashaying'};
        app.sprites.setSprite(obj.enemy);
	}

	obj.update = function(){
		requestAnimationFrame(app.main.update.bind(app.main));
		app.renderer.draw();
		callFunctionMovementButtons.call(this, "drawAndUpdate");
	};
	
	function callFunctionMovementButtons(f, arg){
		var movement = checkMovement();
		if(movement[0]) this.directionButtons.down[f](arg);
		if(movement[1]) this.directionButtons.up[f](arg);
		if(movement[2]) this.directionButtons.right[f](arg);
		if(movement[3]) this.directionButtons.left[f](arg);
	}
	
	function checkMovement(){
		var movement = [];
		var map = app.main.map;
		
		//Down
		if(playerLocation.row < map.length - 1 && map[playerLocation.row + 1][playerLocation.col] == 1){
			movement.push(1);
		} else {
			movement.push(0);
		}
		
		//Up
		if(playerLocation.row > 0 && map[playerLocation.row - 1][playerLocation.col] == 1){
			movement.push(1);
		} else {
			movement.push(0);
		}
		
		//Right
		if(playerLocation.col < map[0].length - 1 && map[playerLocation.row][playerLocation.col + 1] == 1){
			movement.push(1);
		} else {
			movement.push(0);
		}
		
		//Left
		if(playerLocation.col > 0 && map[playerLocation.row][playerLocation.col - 1] == 1){
			movement.push(1);
		} else {
			movement.push(0);
		}
		
		return movement;
	}
	
	function movePlayer(direction){
		switch(direction){
		case "down":
			playerLocation.row++;
			break;
		case "up":
			playerLocation.row--;
			break;
		case "right":
			playerLocation.col++;
			break;
		case "left":
			playerLocation.col--;
			break;
		}
	}

	return obj;
}();


// by the design of addOnLoadEvent, this will execute after every module has finished all its
// onload logic (that is, they should be more or less initialized, save for JSON requests)
function onOnLoadEventsComplete(){

	app.main.init();

	// we need the bind here because requestAnimationFrame destroys the scope of update
	// when it uses it as a callback
	window.requestAnimationFrame(app.main.update.bind(app.main));

}
window.onload = onOnLoadEventsComplete;

// adds the function f that is passed in to a massive window.onload function
// in short, it consolidates all the logic we need on page load into a single function, 
// so that we can keep onload logic within the individual modules for organization
// and readability
function addOnLoadEvent(f){
	var prevOnLoad = window.onload;
	if( typeof window.onload != 'function'){
		window.onload = f;
	}
	else{
		window.onload = function(){
			f();
			if(prevOnLoad){ // first function in, last function called. important for implementation.
				prevOnLoad();
			}
		}
	}

};

//This is going here for now, because I'm not sure where else to put it

//Get the position of the mouse relative to the display canvas
function getMouse(e){
	var canvas = document.querySelector("canvas");
	var rect = canvas.getBoundingClientRect();
	var point = {
		x: (e.clientX - rect.left),
		y: (e.clientY - rect.top)
	}
	return point;
}

//Create a new button
function Button(ctx, x, y, width, height, color, hoverColor, selectColor, textColor, text, callback){
	//Every button has location data, color data, text data, and an onclick callback
	this.ctx = ctx;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.color = color;
	this.hoverColor = hoverColor;
	this.selectColor = selectColor;
	this.textColor = textColor;
	this.text = text;
	this.callback = callback;
	this.state = "normal";
	
	//Update the button's state
	this.setState = function(state){
		this.state = state;
	}
	
	//Draw and update the button according to its state
	this.drawAndUpdate = function(){
		this.ctx.save();
		switch(this.state){
			case "normal":
				this.ctx.fillStyle = this.color;
				break;
			case "hover":
				this.ctx.fillStyle = this.hoverColor;
				break;
			case "select":
				this.ctx.fillStyle = this.selectColor;
				break;
		}
		this.ctx.fillRect(this.x, this.y, this.width, this.height);
		this.ctx.textBaseline = "middle";
		this.ctx.textAlign = "center";
		this.ctx.font = "30pt verdana";
		this.ctx.fillStyle = this.textColor;
		this.ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);
		this.ctx.restore();
	}
	
	//Check to see if the mouse is hovering over the button
	this.checkHover = function(mouse){
		this.state = mouse.x > this.x && mouse.x < this.x + this.width && mouse.y > this.y && mouse.y < this.y + this.height ? "hover" : "normal";
	}
	
	//Check to see if the mouse has clicked the button
	this.checkClick = function(mouse){
		this.state = mouse.x > this.x && mouse.x < this.x + this.width && mouse.y > this.y && mouse.y < this.y + this.height ? "select" : "normal";
		if(this.state == "select"){
			this.callback();
		}
	}
}