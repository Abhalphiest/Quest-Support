// in short, "use strict" will clean up some of the messier behaviors of javascript,
// and help us to avoid frustrating bugs, in exchange for being stricter about our syntax.
// Errors generated by use strict will show up in the console window of the browser!
"use strict";

// this line at the top of all the files makes sure that they all have access to the same app object,
// independent of when the browser loads the js files. Either app is already defined from another file, or 
// app evaluates to undefined (or false) and then it is instantiated with {} into an empty object.
// each "var app" is thus a pointer to the same object, essentially, even though they are all different variables.
var app = app || {};


// main is instantiated with an IIFE, or immediately invoked function expression. Because the function has a () after its
// closing brace, it is immediately executed upon being declared, and main is assigned its return value. Because the function
// is anonymous, it can never be run again - making its internal scope private to the objects and functions declared within it,
// and effectively making main (and other modules instantiated this way) into a singleton, in some sense. They are initialized 
// once, and their initialization logic can never be executed again elsewhere.
app.main = function(){

	// this obj will eventually be app.main
	var obj = {};
	
	var playerLocation = {row: 0, col: 0};
	
	obj.map = [[1, 0, 2, 4],
		       [2, 1, 1, 0],
			   [0, 0, 1, 0]];
    
    obj.enemy = {type: 'wizlock', trait1: 'timid', trait2: 'talkative'};
	
	//Buttons
	obj.directionButtons = {};

	// loader is a sub module of main, also instantiated with an IIFE.
	// it will be used to load JSON objects asynchronously
	obj.loader = function(){

		// this will eventually be app.main.loader
		var obj = {};

		// this variable will be accessible only to functions inside of app.main.loader
		// it tracks the number of json files that are currently being loaded asynchronously
		// so we can tell when it is safe to proceed with game execution
		var filesLoading = 0;

		// loads a JSON file, and calls the callback function with the data in the JSON file once it has
		// finished loading.
		obj.loadJSON = function(filepath,callback){
			filesLoading++;

			var request = new XMLHttpRequest();
			request.open('GET',filepath);
			request.responseType = 'json';
			request.send();
			request.onload = onResponseReceived;
			request.onerror = function(){console.log("error loading "+ filepath);};
			

			function onResponseReceived(){
				callback(request.response);
				filesLoading--;
			}

		};

		return obj;
	}();
	
	obj.init = function(){
		//Initialization code goes here?
		
		var canvas = document.querySelector("canvas");
		var ctx = canvas.getContext('2d');
		
		canvas.onmousemove = function(e){
			var mouse = getMouse(e);
            callFunctionMovementButtons.call(app.main, "checkHover", mouse);
            callFunctionEncounterButtons.call(app.main, "checkHover", mouse);
		};
		
		canvas.onmousedown = function(e){
			var mouse = getMouse(e);
            callFunctionMovementButtons.call(app.main, "checkClick", mouse);
            callFunctionEncounterButtons.call(app.main, "checkClick", mouse);
		};
		
		app.main.directionButtons = {
			left: new Button(ctx, canvas.width / 2 - 250, canvas.height / 2 - 50, 200, 100, "grey", "green", "red", "white", "Go Left",
			function(){movePlayer("left")}),
			right: new Button(ctx, canvas.width / 2 + 100, canvas.height / 2 - 50, 200, 100, "grey", "green", "red", "white", "Go Right",
			function(){movePlayer("right")}),
			up: new Button(ctx, canvas.width / 2 - 100, canvas.height / 2 - 200, 200, 100, "grey", "green", "red", "white", "Go Up",
			function(){movePlayer("up")}),
			down: new Button(ctx, canvas.width / 2 - 100, canvas.height / 2 + 100, 200, 100, "grey", "green", "red", "white", "Go Down",
			function(){movePlayer("down")})
		};
        app.main.choiceButtons = {
            cOne: new Button(ctx, (canvas.width / 8), (canvas.height / 5), 200, 50, "grey", "green", "red", "white", "1",
                function () { checkAnswer(app.main.choiceButtons.cOne.text); }),
            cTwo: new Button(ctx, (canvas.width / 8) * 2, (canvas.height / 5), 200, 50, "grey", "green", "red", "white", "2",
                function () { checkAnswer(app.main.choiceButtons.cTwo.text);}),
            cThree: new Button(ctx, (canvas.width / 8) * 3, (canvas.height / 5), 200, 50, "grey", "green", "red", "white", "3",
                function () { checkAnswer(app.main.choiceButtons.cThree.text);}),
            cFour: new Button(ctx, (canvas.width / 8) * 4, (canvas.height / 5), 200, 50, "grey", "green", "red", "white", "4",
                function () { checkAnswer(app.main.choiceButtons.cFour.text);}),
            cFive: new Button(ctx, (canvas.width / 8) * 5, (canvas.height / 5), 200, 50, "grey", "green", "red", "white", "5",
                function () { checkAnswer(app.main.choiceButtons.cFive.text);}),
            cSix: new Button(ctx, (canvas.width / 8) * 6, (canvas.height / 5), 200, 50, "grey", "green", "red", "white", "6",
                function () { checkAnswer(app.main.choiceButtons.cSix.text);})
        };
        app.main.otherButtons = {
            talk: new Button(ctx, canvas.width / 2 - 375, canvas.height - 100, 200, 50, "grey", "green", "red", "white", "Talk",
                function () { changeEncounterText(app.main.otherButtons.talk.text); }),
            inspect: new Button(ctx, canvas.width / 2 + 175, canvas.height - 100, 200, 50, "grey", "green", "red", "white", "Inspect",
                function () { changeEncounterText(app.main.otherButtons.inspect.text);}),
        };
        
        app.main.enemy = {type: 'wizlock', trait1: 'foppish', trait2: 'sashaying'};
        app.sprites.setSprite(obj.enemy);

        app.main.gameStates = {
            ENCOUNTER : 0,
            TRAVELING: 1,
            ENDING: 2
        }
        app.main.currentState = app.main.gameStates.TRAVELING;
        app.main.ctx = ctx;
        app.main.encounterText = "STARTING ENCOUNTER TEXT";
	}

	obj.update = function(){
		requestAnimationFrame(app.main.update.bind(app.main));
        app.renderer.draw();
        if (app.main.currentState != app.main.gameStates.ENDING) {
            if (app.main.currentState == app.main.gameStates.TRAVELING) {
                callFunctionMovementButtons.call(this, "drawAndUpdate");
            }
            if (app.main.currentState == app.main.gameStates.ENCOUNTER) {
                callFunctionEncounterButtons.call(this, "drawAndUpdate");
            }
        } else {
            this.ctx.font = "20pt verdana";
            this.ctx.fillStyle = "black";
            this.ctx.fillText("End of the current floor", 500, 500);  
        }
        
	};
	
    function callFunctionMovementButtons(f, arg) {
            var movement = checkMovement();
            if (movement[0]) this.directionButtons.down[f](arg);
            if (movement[1]) this.directionButtons.up[f](arg);
            if (movement[2]) this.directionButtons.right[f](arg);
            if (movement[3]) this.directionButtons.left[f](arg);	
    }

    function callFunctionEncounterButtons(f, arg) {
        
            app.main.choiceButtons.cOne[f](arg);
            //app.main.choiceButtons.cOne.text = "7";
            app.main.choiceButtons.cTwo[f](arg);
            app.main.choiceButtons.cThree[f](arg);
            app.main.choiceButtons.cFour[f](arg);
            app.main.choiceButtons.cFive[f](arg);
            app.main.choiceButtons.cSix[f](arg);
            app.main.otherButtons.talk[f](arg);
            app.main.otherButtons.inspect[f](arg);
            this.ctx.font = "20pt verdana";
            this.ctx.fillStyle = "black";
            this.ctx.fillText(app.main.encounterText, 500, 100);   
    }
	
	function checkMovement(){
		var movement = [];
		var map = app.main.map;
		
		//Down
		if(playerLocation.row < map.length - 1 && map[playerLocation.row + 1][playerLocation.col] != 0){
			movement.push(1);
		} else {
			movement.push(0);
		}
		
		//Up
		if(playerLocation.row > 0 && map[playerLocation.row - 1][playerLocation.col] != 0){
			movement.push(1);
		} else {
			movement.push(0);
		}
		
		//Right
		if(playerLocation.col < map[0].length - 1 && map[playerLocation.row][playerLocation.col + 1] != 0){
			movement.push(1);
		} else {
			movement.push(0);
		}
		
		//Left
		if(playerLocation.col > 0 && map[playerLocation.row][playerLocation.col - 1] != 0){
			movement.push(1);
		} else {
			movement.push(0);
		}
		
		return movement;
	}
	
	function movePlayer(direction){
		switch(direction){
		case "down":
            playerLocation.row++;               
			break;
		case "up":
			playerLocation.row--;
			break;
		case "right":
			playerLocation.col++;
			break;
		case "left":
			playerLocation.col--;
			break;
        }
        if (app.main.map[playerLocation.row][playerLocation.col] == 2) {
            app.main.currentState = app.main.gameStates.ENCOUNTER;
        }
        if (app.main.map[playerLocation.row][playerLocation.col] == 4) {
            app.main.currentState = app.main.gameStates.ENDING;
        }
	}


    //Will randomize the answers of the buttons
    //
    //
    function randomizeAnswers() {

    }
    //Change the encounterText based off of talk or inspect button push

    function changeEncounterText(text) {
        if (text == "Talk") {
            console.dir("Talk");
        }
        else if (text == "Inspect") {
            console.dir("Inspect");
        }
    }

    //Check if answer is correct
    //
    function checkAnswer(text) {
        console.dir(text);
        //Arbitrary correct answer
        if (text == "6") {
            app.main.map[playerLocation.row][playerLocation.col] = 3;
            app.main.currentState = app.main.gameStates.TRAVELING;
        }
    }


	return obj;
}();


// by the design of addOnLoadEvent, this will execute after every module has finished all its
// onload logic (that is, they should be more or less initialized, save for JSON requests)
function onOnLoadEventsComplete(){

	app.main.init();

	// we need the bind here because requestAnimationFrame destroys the scope of update
	// when it uses it as a callback
	window.requestAnimationFrame(app.main.update.bind(app.main));

}
window.onload = onOnLoadEventsComplete;

// adds the function f that is passed in to a massive window.onload function
// in short, it consolidates all the logic we need on page load into a single function, 
// so that we can keep onload logic within the individual modules for organization
// and readability
function addOnLoadEvent(f){
	var prevOnLoad = window.onload;
	if( typeof window.onload != 'function'){
		window.onload = f;
	}
	else{
		window.onload = function(){
			f();
			if(prevOnLoad){ // first function in, last function called. important for implementation.
				prevOnLoad();
			}
		}
	}

};





//This is going here for now, because I'm not sure where else to put it

//Get the position of the mouse relative to the display canvas
function getMouse(e){
	var canvas = document.querySelector("canvas");
	var rect = canvas.getBoundingClientRect();
	var point = {
		x: (e.clientX - rect.left),
		y: (e.clientY - rect.top)
	}
	return point;
}

//Create a new button
function Button(ctx, x, y, width, height, color, hoverColor, selectColor, textColor, text, callback){
	//Every button has location data, color data, text data, and an onclick callback
	this.ctx = ctx;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.color = color;
	this.hoverColor = hoverColor;
	this.selectColor = selectColor;
	this.textColor = textColor;
	this.text = text;
	this.callback = callback;
	this.state = "normal";
	//Update the button's state
	this.setState = function(state){
		this.state = state;
	}
	
	//Draw and update the button according to its state
	this.drawAndUpdate = function(){
        this.ctx.save();
        switch (this.state) {
            case "normal":
                this.ctx.fillStyle = this.color;
                break;
            case "hover":
                this.ctx.fillStyle = this.hoverColor;
                break;
            case "select":
                this.ctx.fillStyle = this.selectColor;
                break;
        }
        this.ctx.fillRect(this.x, this.y, this.width, this.height);
        this.ctx.textBaseline = "middle";
        this.ctx.textAlign = "center";
        this.ctx.font = "30pt verdana";
        this.ctx.fillStyle = this.textColor;
        this.ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);
	}
	
	//Check to see if the mouse is hovering over the button
	this.checkHover = function(mouse){
		this.state = mouse.x > this.x && mouse.x < this.x + this.width && mouse.y > this.y && mouse.y < this.y + this.height ? "hover" : "normal";
	}
	
	//Check to see if the mouse has clicked the button
	this.checkClick = function(mouse){
		this.state = mouse.x > this.x && mouse.x < this.x + this.width && mouse.y > this.y && mouse.y < this.y + this.height ? "select" : "normal";
		if(this.state == "select"){
			this.callback();
		}
    }

 
}